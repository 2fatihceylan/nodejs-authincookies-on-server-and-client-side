/*! @azure/msal-browser v3.6.0 2023-12-01 */
'use strict';
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * BridgeProxy
 * Provides a proxy for accessing a bridge to a host app and/or
 * platform broker
 */
class BridgeProxy {
    /**
     * initializeNestedAppAuthBridge - Initializes the bridge to the host app
     * @returns a promise that resolves to an InitializeBridgeResponse or rejects with an Error
     * @remarks This method will be called by the create factory method
     * @remarks If the bridge is not available, this method will throw an error
     */
    static async initializeNestedAppAuthBridge() {
        if (window === undefined) {
            throw new Error("window is undefined");
        }
        if (window.nestedAppAuthBridge === undefined) {
            throw new Error("window.nestedAppAuthBridge is undefined");
        }
        if (window.crypto === undefined) {
            throw new Error("window.crypto is undefined");
        }
        try {
            BridgeProxy.crypto = window.crypto;
            window.nestedAppAuthBridge.addEventListener("message", (response) => {
                const responsePayload = typeof response === "string" ? response : response.data;
                const responseEnvelope = JSON.parse(responsePayload);
                const request = BridgeProxy.bridgeRequests.find((element) => element.requestId === responseEnvelope.requestId);
                if (request !== undefined) {
                    BridgeProxy.bridgeRequests.splice(BridgeProxy.bridgeRequests.indexOf(request), 1);
                    if (responseEnvelope.success) {
                        request.resolve(responseEnvelope.body);
                    }
                    else {
                        request.reject(responseEnvelope.body);
                    }
                }
            });
            const promise = new Promise((resolve, reject) => {
                const message = {
                    messageType: "NestedAppAuthRequest",
                    method: "GetInitContext",
                    requestId: BridgeProxy.getRandomId(),
                };
                const request = {
                    requestId: message.requestId,
                    method: message.method,
                    resolve: resolve,
                    reject: reject,
                };
                BridgeProxy.bridgeRequests.push(request);
                window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
            });
            return await promise;
        }
        catch (error) {
            window.console.log(error);
            throw error;
        }
    }
    static getRandomId() {
        return BridgeProxy.crypto.randomUUID();
    }
    /**
     * getTokenInteractive - Attempts to get a token interactively from the bridge
     * @param request A token request
     * @returns a promise that resolves to a token response or rejects with a BridgeError
     */
    getTokenInteractive(request) {
        return this.sendRequest("GetTokenPopup", request);
    }
    /**
     * getTokenSilent Attempts to get a token silently from the bridge
     * @param request A token request
     * @returns a promise that resolves to a token response or rejects with a BridgeError
     */
    getTokenSilent(request) {
        return this.sendRequest("GetToken", request);
    }
    /**
     * getAccountInfo - Gets account information from the bridge
     *
     * @param request A request for account information
     */
    getAccountInfo(request) {
        let method = "GetAccountByHomeId";
        if (request.homeAccountId !== undefined) {
            method = "GetAccountByHomeId";
        }
        if (request.localAccountId !== undefined) {
            method = "GetAccountByLocalId";
        }
        if (request.username !== undefined) {
            method = "GetAccountByUsername";
        }
        return this.sendRequest(method, request);
    }
    getActiveAccount() {
        return this.sendRequest("GetActiveAccount", undefined);
    }
    getHostCapabilities() {
        return this.capabilities ?? null;
    }
    /**
     * A method used to send a request to the bridge
     * @param request A token request
     * @returns a promise that resolves to a response of provided type or rejects with a BridgeError
     */
    sendRequest(method, request) {
        const message = {
            messageType: "NestedAppAuthRequest",
            method: method,
            requestId: BridgeProxy.getRandomId(),
            body: request,
        };
        const promise = new Promise((resolve, reject) => {
            const request = {
                requestId: message.requestId,
                method: message.method,
                resolve: resolve,
                reject: reject,
            };
            BridgeProxy.bridgeRequests.push(request);
            window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
        });
        return promise;
    }
    /**
     * Private constructor for BridgeProxy
     * @param sdkName The name of the SDK being used to make requests on behalf of the app
     * @param sdkVersion The version of the SDK being used to make requests on behalf of the app
     * @param capabilities The capabilities of the bridge / SDK / platform broker
     */
    constructor(sdkName, sdkVersion, capabilities) {
        this.sdkName = sdkName;
        this.sdkVersion = sdkVersion;
        this.capabilities = capabilities;
    }
    /**
     * Factory method for creating an implementation of IBridgeProxy
     * @returns A promise that resolves to a BridgeProxy implementation
     */
    static async create() {
        const response = await BridgeProxy.initializeNestedAppAuthBridge();
        return new BridgeProxy(response.sdkName, response.sdkVersion, response.capabilities);
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
BridgeProxy.bridgeRequests = [];

export { BridgeProxy, BridgeProxy as default };
//# sourceMappingURL=BridgeProxy.mjs.map
